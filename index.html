<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Jaffar ∞ Vision — Web (TFJS + Pose + Hands + CLIP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    *{box-sizing:border-box}html,body{height:100%;margin:0}
    body{font-family:Inter,Segoe UI,Arial,sans-serif;background:#0b0f19;color:#e9eefb;overflow:hidden}
    #bg{position:fixed;inset:0;z-index:0}
    .overlay{position:relative;z-index:1;display:flex;align-items:center;justify-content:center;height:100%;padding:24px}
    .brand{position:absolute;top:24px;left:32px;font-weight:800;font-size:28px;color:#cde3ff;text-shadow:0 0 18px rgba(120,180,255,.4);user-select:none;cursor:default}
    .brand span{margin-left:6px;color:#86ffe5}
    .panel{width:min(1100px,94vw);padding:18px;border-radius:16px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter: blur(12px);box-shadow:0 10px 40px rgba(0,0,0,.45)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
    button,select,input[type=range]{background:#1a71ff;color:#fff;border:none;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer}
    select{background:#0f1322;border:1px solid rgba(255,255,255,.15);color:#cde3ff}
    input[type=range]{width:160px}
    .pill{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);color:#cde3ff;font-weight:700}
    .stack{position:relative;width:100%}
    #cam{width:100%;max-height:58vh;border-radius:12px;background:#000;display:block}
    #overlay{position:absolute;left:0;top:0;pointer-events:none}
    .desc{min-height:28px;margin-top:8px;padding:10px 12px;background:rgba(10,16,28,.55);border:1px solid rgba(255,255,255,.12);border-radius:10px}
    .debug{margin-top:8px;padding:10px 12px;background:rgba(255,100,100,.1);border:1px solid rgba(255,150,150,.25);border-radius:10px;font-family:ui-monospace,Consolas,monospace;white-space:pre-wrap;max-height:22vh;overflow:auto}
    .right{margin-left:auto}
    .hint{margin-top:8px;padding:10px 12px;background:rgba(255,200,0,.12);border:1px solid rgba(255,200,0,.35);border-radius:10px;display:none}
    .stats{position:absolute;right:20px;bottom:24px;min-width:260px;max-width:40vw;max-height:40vh;overflow:auto;padding:10px 12px;border-radius:10px;background:rgba(100,255,180,.08);border:1px solid rgba(100,255,180,.25);font-family:ui-monospace,Consolas,monospace;white-space:pre-wrap;display:none}
    .toggle{background:#0f1322;border:1px solid rgba(255,255,255,.15);color:#cde3ff;border-radius:10px;padding:8px 10px}
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <div class="overlay">
    <div class="brand" id="brand">Jaffar<span>∞</span> Vision</div>
    <div class="panel">
      <div class="row">
        <button id="startBtn">Start Camera</button>
        <button id="autoBtn">Auto: OFF</button>
        <button id="snapBtn" style="background:#15b26b">DETECT ONCE</button>
        <label class="pill">Conf <span id="confVal">0.55</span></label>
        <input id="conf" type="range" min="0.2" max="0.95" step="0.05" value="0.55">
        <select id="camSelect" title="Camera"></select>
        <span class="pill right" id="status">Model: loading…</span>
      </div>
      <div class="row">
        <label class="toggle"><input id="deepToggle" type="checkbox" checked/> Deep Classifier (CLIP)</label>
        <label class="toggle"><input id="handsToggle" type="checkbox" checked/> Hand Gestures</label>
        <label class="toggle"><input id="poseToggle" type="checkbox" checked/> Pose (Raise Hand)</label>
        <label class="toggle">Auto CLIP/Hands every <input id="deepInterval" type="number" min="3" max="60" value="10" style="width:60px;background:#0f1322;color:#cde3ff;border:1px solid rgba(255,255,255,.2);border-radius:8px;padding:6px"/> frames</label>
      </div>
      <div class="stack">
        <video id="cam" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div id="desc" class="desc">No clear objects.</div>
      <div id="hint" class="hint"></div>
      <div id="dbg" class="debug">Debug log…</div>
    </div>
    <div id="stats" class="stats"></div>
  </div>

  <!-- BG particles -->
  <script>
    const b=document.getElementById('bg'); const bx=b.getContext('2d');
    let W,H,P=[]; const N=100; function R(a,b){return Math.random()*(b-a)+a}
    function size(){W=b.width=innerWidth; H=b.height=innerHeight; P=[...Array(N)].map(_=>({x:R(0,W),y:R(0,H),vx:R(-.3,.3),vy:R(-.3,.3),r:R(.6,1.8),a:R(.25,.85)}))}
    addEventListener('resize', size); size();
    (function loop(){bx.clearRect(0,0,W,H); for(const p of P){p.x+=p.vx;p.y+=p.vy;if(p.x<0||p.x>W)p.vx*=-1;if(p.y<0||p.y>H)p.vy*=-1;bx.beginPath();bx.arc(p.x,p.y,p.r,0,Math.PI*2);bx.fillStyle=`rgba(120,180,255,${p.a})`;bx.fill()} requestAnimationFrame(loop)})();
  </script>

  <!-- Core ML libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
  <!-- MediaPipe Hands assets (for runtime:'mediapipe') -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
  <!-- Zero-shot CLIP in-browser -->
  <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers/dist/transformers.min.js"></script>

  <script>
    // DOM
    const cam=document.getElementById('cam'), overlay=document.getElementById('overlay');
    const startBtn=document.getElementById('startBtn'), autoBtn=document.getElementById('autoBtn'), snapBtn=document.getElementById('snapBtn');
    const conf=document.getElementById('conf'), confVal=document.getElementById('confVal'), camSelect=document.getElementById('camSelect');
    const statusEl=document.getElementById('status'), desc=document.getElementById('desc'), dbg=document.getElementById('dbg'), hint=document.getElementById('hint');
    const statsBox=document.getElementById('stats'), brand=document.getElementById('brand');
    const deepToggle=document.getElementById('deepToggle'), handsToggle=document.getElementById('handsToggle'), poseToggle=document.getElementById('poseToggle');
    const deepIntervalEl=document.getElementById('deepInterval');

    function log(x){ dbg.textContent += '\n' + x; dbg.scrollTop = dbg.scrollHeight; console.log(x); }

    // State
    let model=null, poseDetector=null, handsDetector=null, clipPipe=null;
    let auto=false, currentDeviceId=null;
    let tracks=[]; let nextId=1;
    let lastTime=performance.now(), frames=0;
    let lastRun=0, minInterval=40; // ~25 FPS
    let devicesCache=[]; let camIndex=0;
    let deepFrameCounter=0;

    // CLIP labels (يمكنك تعديلها لاحقًا)
    const CLIP_LABELS = [
      // phones
      "iPhone", "Samsung phone", "Huawei phone", "Xiaomi phone", "smartphone",
      // clothing
      "t-shirt", "shirt", "jacket", "hoodie", "jeans", "trousers", "belt", "dress", "skirt", "hat",
      // fruits
      "apple", "banana", "orange", "grape", "strawberry", "watermelon", "pineapple", "peach",
      // misc common
      "cup", "bottle", "laptop", "keyboard", "mouse", "backpack"
    ];

    // Backends
    async function pickBackend(){
      const prefs=['webgpu','webgl','wasm'];
      for(const b of prefs){
        try{ await tf.setBackend(b); await tf.ready(); log('Backend: '+tf.getBackend()); break; }
        catch(e){ log('Backend fail '+b+': '+e.message); }
      }
      try{ tf.env().set('WEBGPU_USE_FP16', true); }catch{}
      statusEl.textContent = `Model: loading… (backend ${tf.getBackend()})`;
    }

    function fitOverlay(){
      overlay.width = cam.videoWidth || 640;
      overlay.height = cam.videoHeight || 480;
      overlay.style.width = cam.clientWidth + 'px';
      overlay.style.height = cam.clientHeight + 'px';
    }

    // Simple color name for boxes
    function simpleColorName(r,g,b){
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const s = max===0?0:(max-min)/max;
      if(max<40) return 'black';
      if(min>220) return 'white';
      if(s<0.1) return 'gray';
      if(r>g+20 && r>b+20) return 'red';
      if(g>r+20 && g>b+20) return 'green';
      if(b>r+20 && b>g+20) return 'blue';
      if(r>180 && g>180 && b<120) return 'yellow';
      return 'color';
    }
    function avgColorInBox([x,y,w,h]){
      const tmp=document.createElement('canvas'); tmp.width=Math.max(1,Math.floor(w)); tmp.height=Math.max(1,Math.floor(h));
      const tctx=tmp.getContext('2d',{willReadFrequently:true});
      tctx.drawImage(cam, x, y, w, h, 0, 0, tmp.width, tmp.height);
      const {data} = tctx.getImageData(0,0,tmp.width,tmp.height);
      let r=0,g=0,b=0,n=data.length/4;
      for(let i=0;i<data.length;i+=4){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; }
      r=Math.round(r/n); g=Math.round(g/n); b=Math.round(b/n);
      return {r,g,b,name:simpleColorName(r,g,b)};
    }

    // Tracking (IoU + smoothing)
    function iou(a,b){
      const [ax,ay,aw,ah]=a, [bx,by,bw,bh]=b;
      const x1=Math.max(ax,bx), y1=Math.max(ay,by);
      const x2=Math.min(ax+aw,bx+bw), y2=Math.min(ay+ah,bx+bh);
      const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1);
      const ua=aw*ah + bw*bh - inter;
      return ua>0? inter/ua : 0;
    }
    function updateTracks(dets, threshold){
      const matched=new Set(), newTracks=[];
      for(const t of tracks){
        let best=null, bestIoU=0, bestIdx=-1;
        for(let i=0;i<dets.length;i++){
          if(matched.has(i)) continue;
          const d=dets[i]; if(d.score<threshold) continue;
          const ov = iou(t.bbox, d.bbox);
          if(ov>bestIoU){ bestIoU=ov; bestIdx=i; best=d; }
        }
        if(bestIoU>0.25){
          matched.add(bestIdx);
          const nb = best.bbox.map((v,i)=> 0.7*t.bbox[i] + 0.3*v );
          newTracks.push({id:t.id, class:best.class, bbox:nb, score:best.score, miss:0, clip: t.clip||null});
        }else{
          if(t.miss<2) newTracks.push({...t, miss:t.miss+1});
        }
      }
      for(let i=0;i<dets.length;i++){
        if(matched.has(i)) continue;
        const d=dets[i];
        if(d.score>=threshold){
          newTracks.push({id:nextId++, class:d.class, bbox:d.bbox, score:d.score, miss:0, clip:null});
        }
      }
      tracks=newTracks;
      return tracks.filter(t=>t.miss===0);
    }

    // Draw
    function drawBoxes(items, extra=undefined){
      const ctx=overlay.getContext('2d');
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.lineWidth=2; ctx.font='14px ui-monospace, Consolas, monospace';
      items.forEach(o=>{
        const [x,y,w,h]=o.bbox;
        ctx.strokeStyle='rgba(120,180,255,0.95)';
        ctx.fillStyle='rgba(10,16,28,0.75)';
        if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(x,y,w,h,8); ctx.stroke(); }
        else { ctx.strokeRect(x,y,w,h); }
        let tag = `${o.class}${o.color?` (${o.color.name})`:''} ${o.score.toFixed(2)} #${o.id}`;
        if (o.clip && o.clip.label && o.clip.score){
          tag += ` · ${o.clip.label} ${o.clip.score.toFixed(2)}`;
        }
        const tw = ctx.measureText(tag).width+8;
        ctx.fillRect(x, Math.max(0,y-20), tw, 20);
        ctx.fillStyle='#cde3ff'; ctx.fillText(tag, x+4, y-6);
      });
      // Write extra messages top-left
      if(extra){
        ctx.font='16px ui-monospace, Consolas, monospace';
        ctx.fillStyle='#86ffe5';
        ctx.fillText(extra, 12, 22);
      }
    }

    function drawPose(poseInfo){
      if(!poseInfo) return;
      const ctx = overlay.getContext('2d');
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      poseInfo.keypoints.forEach(p=>{
        const sc = (p.score ?? p.confidence ?? 0);
        if(sc > 0.45){
          ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
        }
      });
    }

    // Summaries
    function summarize(items, poseInfo, gestureSummary){
      const parts=[];
      if(items.length){
        const counts={}; items.forEach(p=> counts[p.class]=(counts[p.class]||0)+1 );
        const ordered=Object.entries(counts).sort((a,b)=>b[1]-a[1]).map(([k,v])=>`${k}: ${v}`).join(', ');
        parts.push('Objects '+ordered);
      }
      if(poseInfo && (poseInfo.leftUp || poseInfo.rightUp)){
        parts.push('Gestures ' + [
          poseInfo.leftUp?'Left hand up':null,
          poseInfo.rightUp?'Right hand up':null
        ].filter(Boolean).join(' & '));
      }
      if(gestureSummary) parts.push(gestureSummary);
      desc.textContent = parts.length? parts.join(' — ')+'.' : 'No clear objects.';
    }

    function tickFps(){
      frames++; const now=performance.now();
      if(now-lastTime>1000){
        statusEl.textContent=`Model: ready ✅ — FPS ${frames}`;
        frames=0; lastTime=now;
      }
    }

    // === Hand Gestures (heuristics) ===
    // MediaPipe Hands keypoints indices (normalized order):
    // 0:wrist, then per finger: [MCP, PIP, DIP, tip]
    const FINGERS = {
      thumb:  [1,2,3,4],
      index:  [5,6,7,8],
      middle: [9,10,11,12],
      ring:   [13,14,15,16],
      pinky:  [17,18,19,20],
    };
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function fingerExtended(landmarks, finger, wrist, norm){
      const ids = FINGERS[finger];
      const tip = landmarks[ids[3]]; const pip = landmarks[ids[1]];
      const d = dist(tip, wrist)/norm;
      const bend = dist(tip, pip)/norm;
      return d>0.35 && bend>0.18; // تقريبية
    }
    function classifyGesture(h){
      const lm = h.keypoints3D?.length ? h.keypoints3D : h.keypoints; // fallback
      if(!lm || lm.length<21) return null;
      const wrist = lm[0];
      const norm = dist(lm[5], lm[17]) || 1; // عرض الكف التقريبي
      const ext = {
        thumb:  fingerExtended(lm,'thumb', wrist, norm),
        index:  fingerExtended(lm,'index', wrist, norm),
        middle: fingerExtended(lm,'middle',wrist, norm),
        ring:   fingerExtended(lm,'ring',  wrist, norm),
        pinky:  fingerExtended(lm,'pinky', wrist, norm),
      };
      const extendedCount = Object.values(ext).filter(Boolean).length;
      // قواعد بسيطة:
      if(extendedCount>=4) return 'Open Palm';
      if(extendedCount<=1) return 'Fist';
      if(ext.index && ext.middle && !ext.ring && !ext.pinky) return 'Peace ✌️';
      // إبهام للأعلى: الإبهام ممتد والباقي غير ممتدين تقريبًا
      if(ext.thumb && !ext.index && !ext.middle) return 'Thumbs Up 👍';
      return null;
    }

    // === Zero-shot CLIP classification on crops ===
    async function clipClassifyCrops(items, topK=3){
      if(!clipPipe || !deepToggle.checked || !items.length) return;
      // اختَر أكبر مربعات
      const sorted = [...items].sort((a,b)=>(b.bbox[2]*b.bbox[3])-(a.bbox[2]*a.bbox[3])).slice(0, topK);
      const tmp=document.createElement('canvas'); const tctx=tmp.getContext('2d',{willReadFrequently:true});
      for(const it of sorted){
        const [x,y,w,h]=it.bbox.map(v=>Math.max(0, Math.floor(v)));
        if(w<32 || h<32) continue;
        tmp.width=w; tmp.height=h;
        tctx.drawImage(cam, x, y, w, h, 0, 0, w, h);
        const res = await clipPipe(tmp, CLIP_LABELS);
        // res = [{label, score}, ...] sorted
        if(res && res.length){
          const best = res[0];
          // خزّن في التراك
          const t = tracks.find(tk=>tk.id===it.id);
          if(t){ t.clip = {label:best.label, score:best.score}; it.clip=t.clip; }
        }
      }
    }

    // Detection main
    async function detectOnce(){
      try{
        fitOverlay();
        const threshold=parseFloat(conf.value);

        // COCO-SSD
        const preds = await model.detect(cam);
        const keep = preds.filter(p=>p.score>=threshold).map(p=>({
          class:p.class, bbox:p.bbox, score:p.score
        }));
        const active = updateTracks(keep, threshold);
        active.forEach(a=>{ a.color = avgColorInBox(a.bbox); });

        // Pose (raised hands)
        let poseInfo = null;
        if (poseToggle.checked && poseDetector){
          const poses = await poseDetector.estimatePoses(cam, { flipHorizontal:false });
          if (poses && poses[0] && poses[0].keypoints){
            const kp = Object.fromEntries(poses[0].keypoints.map(k => [k.name || k.part || k.index, k]));
            const Ls = kp['leftShoulder'], Rs = kp['rightShoulder'];
            const Lw = kp['leftWrist'],   Rw = kp['rightWrist'];
            function good(p){ return p && (p.score ?? p.confidence ?? 0) > 0.45; }
            let leftUp=false, rightUp=false;
            if (good(Ls) && good(Lw)) { leftUp  = (Lw.y < Ls.y - 10); }
            if (good(Rs) && good(Rw)) { rightUp = (Rw.y < Rs.y - 10); }
            poseInfo = { leftUp, rightUp, keypoints: poses[0].keypoints };
          }
        }

        // Hands + gestures
        let gestureSummary = '';
        if(handsToggle.checked && handsDetector){
          const hands = await handsDetector.estimateHands(cam, {flipHorizontal:false});
          const ctx = overlay.getContext('2d');
          ctx.fillStyle='rgba(255,255,255,0.9)';
          hands.forEach(h=>{
            h.keypoints.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill(); });
            const g = classifyGesture(h);
            if(g){ gestureSummary += (gestureSummary? ' | ':'') + g; }
          });
        }

        // CLIP every N frames (or on single detect)
        if(clipPipe){
          deepFrameCounter++;
          const N = Math.max(3, parseInt(deepIntervalEl.value)||10);
          if(!auto || deepFrameCounter % N === 0){
            await clipClassifyCrops(active, 3);
          }
        }

        // Draw + summarize
        drawBoxes(active, gestureSummary);
        if(poseInfo) drawPose(poseInfo);
        summarize(active, poseInfo, gestureSummary);
        tickFps();
      }catch(e){ log('detect error: '+e.message); }
    }

    function autoLoop(t){
      if(!auto) return;
      if(!lastRun || (t-lastRun)>=minInterval){
        lastRun=t;
        detectOnce().finally(()=>{ requestAnimationFrame(autoLoop); });
      }else{
        requestAnimationFrame(autoLoop);
      }
    }

    // Camera
    async function listCams(){
      try{
        const devs = await navigator.mediaDevices.enumerateDevices();
        const vids = devs.filter(d=>d.kind==='videoinput');
        devicesCache = vids;
        camSelect.innerHTML = vids.map((v,i)=>`<option value="${v.deviceId}">${v.label||'Camera '+(i+1)}</option>`).join('');
        if(vids[0]){ currentDeviceId = vids[0].deviceId; camIndex=0; }
        log('Cams: '+vids.map(v=>v.label||v.deviceId).join(', '));
      }catch(e){ log('enumerateDevices error: '+e.message); }
    }
    async function startStream(id=null){
      const cs = { video: id?{deviceId:{exact:id}}:{width:{ideal:960},height:{ideal:720},frameRate:{ideal:30,max:60}}, audio:false };
      const s = await navigator.mediaDevices.getUserMedia(cs);
      cam.srcObject = s;
      await new Promise(r=> cam.onloadedmetadata=r);
      await cam.play();
      fitOverlay();
      log('Cam started '+cam.videoWidth+'x'+cam.videoHeight);
      startBtn.textContent='Camera: ON';
      hint.style.display='none';
    }
    async function startCam(){
      try{
        if(location.protocol!=='https:' && location.hostname!=='localhost'){
          hint.textContent='⚠️ Use HTTPS (GitHub Pages) to access the camera.'; hint.style.display='block';
        }
        await listCams(); await startStream(currentDeviceId);
      }catch(e){
        log('startCam error: '+e.name+' '+e.message);
        statusEl.textContent='Camera blocked';
        if(e.name==='NotAllowedError'){
          hint.textContent='⚠️ Please allow camera access from the address bar.'; hint.style.display='block';
        }else if(e.name==='NotFoundError'){
          hint.textContent='⚠️ No camera found. Plug one or choose another from the selector.'; hint.style.display='block';
        }
      }
    }

    // Stats overlay (hidden UI)
    function renderStats(){
      const entries = Object.entries({}); // reserved
      statsBox.textContent = entries.length? entries.map(([k,v])=>`- ${k}: ${v}`).join('\n') : 'No stats yet.';
    }
    function toggleStats(){
      renderStats();
      statsBox.style.display = (statsBox.style.display==='none'||!statsBox.style.display)?'block':'none';
    }

    // UI wiring
    startBtn.onclick = startCam;
    camSelect.onchange = async e=>{ currentDeviceId=e.target.value; if(cam.srcObject){ cam.srcObject.getTracks().forEach(t=>t.stop()); } await startStream(currentDeviceId); };
    snapBtn.onclick = detectOnce;
    autoBtn.onclick = ()=>{ auto=!auto; autoBtn.textContent='Auto: '+(auto?'ON':'OFF'); if(auto) requestAnimationFrame(autoLoop); };
    conf.oninput = ()=> confVal.textContent = conf.value;

    window.addEventListener('keydown', async (ev)=>{
      if(ev.target && (ev.target.tagName==='INPUT' || ev.target.tagName==='TEXTAREA')) return;
      if(ev.key==='a' || ev.key==='A'){ autoBtn.click(); }
      else if(ev.key===' '){ ev.preventDefault(); snapBtn.click(); }
      else if(ev.key==='+'){ conf.value = Math.min(0.95, (+conf.value + 0.05)).toFixed(2); conf.dispatchEvent(new Event('input')); }
      else if(ev.key==='-'){ conf.value = Math.max(0.2, (+conf.value - 0.05)).toFixed(2); conf.dispatchEvent(new Event('input')); }
      else if(ev.key==='c' || ev.key==='C'){
        if(devicesCache.length>1){
          camIndex = (camIndex+1)%devicesCache.length;
          camSelect.selectedIndex = camIndex;
          const id = devicesCache[camIndex].deviceId;
          if(cam.srcObject){ cam.srcObject.getTracks().forEach(t=>t.stop()); }
          await startStream(id);
        }
      }
      else if(ev.key==='s' || ev.key==='S'){
        if(ev.shiftKey){ toggleStats(); }
        else toggleStats();
      }
    });

    // Init
    (async function init(){
      await pickBackend();

      try{
        model = await cocoSsd.load({base:'mobilenet_v2'});
        statusEl.textContent='Model: ready ✅';
        log('COCO-SSD ready');
      }catch(e){
        statusEl.textContent='Model failed'; log('COCO load error: '+e.message);
      }

      try{
        const PD = window.poseDetection;
        const mdl = PD.SupportedModels.MoveNet;
        poseDetector = await PD.createDetector(mdl, { modelType: PD.movenet.modelType.SINGLEPOSE_LIGHTNING });
        log('Pose model ready');
      }catch(e){
        log('Pose model load error: '+e.message);
      }

      try{
        const HPD = window.handPoseDetection;
        handsDetector = await HPD.createDetector(HPD.SupportedModels.MediaPipeHands, {
          runtime: 'mediapipe',
          solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands',
          modelType: 'lite', // lite/ full
          maxHands: 2
        });
        log('Hands model ready');
      }catch(e){
        log('Hands model load error: '+e.message);
      }

      try{
        // Zero-shot CLIP
        const { pipeline } = window.transformers;
        clipPipe = await pipeline('zero-shot-image-classification', 'Xenova/clip-vit-base-patch32');
        log('CLIP pipeline ready');
      }catch(e){
        log('CLIP load error: '+e.message);
      }

      setTimeout(()=>startCam().catch(()=>{}), 300);
    })();
  </script>
</body>
</html>