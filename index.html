<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Jaffar ∞ Vision — Web (TFJS v3 Boosted+ Pose)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    *{box-sizing:border-box}html,body{height:100%;margin:0}
    body{font-family:Inter,Segoe UI,Arial,sans-serif;background:#0b0f19;color:#e9eefb;overflow:hidden}
    #bg{position:fixed;inset:0;z-index:0}
    .overlay{position:relative;z-index:1;display:flex;align-items:center;justify-content:center;height:100%;padding:24px}
    .brand{position:absolute;top:24px;left:32px;font-weight:800;font-size:28px;color:#cde3ff;text-shadow:0 0 18px rgba(120,180,255,.4);user-select:none;cursor:default}
    .brand span{margin-left:6px;color:#86ffe5}
    .panel{width:min(1100px,94vw);padding:18px;border-radius:16px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter: blur(12px);box-shadow:0 10px 40px rgba(0,0,0,.45)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
    button,select,input[type=range]{background:#1a71ff;color:#fff;border:none;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer}
    select{background:#0f1322;border:1px solid rgba(255,255,255,.15);color:#cde3ff}
    input[type=range]{width:160px}
    .pill{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);color:#cde3ff;font-weight:700}
    .stack{position:relative;width:100%}
    #cam{width:100%;max-height:58vh;border-radius:12px;background:#000;display:block}
    #overlay{position:absolute;left:0;top:0;pointer-events:none}
    .desc{min-height:28px;margin-top:8px;padding:10px 12px;background:rgba(10,16,28,.55);border:1px solid rgba(255,255,255,.12);border-radius:10px}
    .debug{margin-top:8px;padding:10px 12px;background:rgba(255,100,100,.1);border:1px solid rgba(255,150,150,.25);border-radius:10px;font-family:ui-monospace,Consolas,monospace;white-space:pre-wrap;max-height:22vh;overflow:auto}
    .right{margin-left:auto}
    .hint{margin-top:8px;padding:10px 12px;background:rgba(255,200,0,.12);border:1px solid rgba(255,200,0,.35);border-radius:10px;display:none}
    .stats{position:absolute;right:20px;bottom:24px;min-width:260px;max-width:40vw;max-height:40vh;overflow:auto;padding:10px 12px;border-radius:10px;background:rgba(100,255,180,.08);border:1px solid rgba(100,255,180,.25);font-family:ui-monospace,Consolas,monospace;white-space:pre-wrap;display:none}
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <div class="overlay">
    <div class="brand" id="brand">Jaffar<span>∞</span> Vision</div>
    <div class="panel">
      <div class="row">
        <button id="startBtn">Start Camera</button>
        <button id="autoBtn">Auto: OFF</button>
        <button id="snapBtn" style="background:#15b26b">DETECT ONCE</button>
        <label class="pill">Conf <span id="confVal">0.5</span></label>
        <input id="conf" type="range" min="0.2" max="0.95" step="0.05" value="0.5">
        <select id="camSelect" title="Camera"></select>
        <span class="pill right" id="status">Model: loading…</span>
      </div>
      <div class="stack">
        <video id="cam" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div id="desc" class="desc">No clear objects.</div>
      <div id="hint" class="hint"></div>
      <div id="dbg" class="debug">Debug log…</div>
    </div>
    <div id="stats" class="stats"></div>
  </div>

  <!-- BG particles -->
  <script>
    const b=document.getElementById('bg'); const bx=b.getContext('2d');
    let W,H,P=[]; const N=100; function R(a,b){return Math.random()*(b-a)+a}
    function size(){W=b.width=innerWidth; H=b.height=innerHeight; P=[...Array(N)].map(_=>({x:R(0,W),y:R(0,H),vx:R(-.3,.3),vy:R(-.3,.3),r:R(.6,1.8),a:R(.25,.85)}))}
    addEventListener('resize', size); size();
    (function loop(){bx.clearRect(0,0,W,H); for(const p of P){p.x+=p.vx;p.y+=p.vy;if(p.x<0||p.x>W)p.vx*=-1;if(p.y<0||p.y>H)p.vy*=-1;bx.beginPath();bx.arc(p.x,p.y,p.r,0,Math.PI*2);bx.fillStyle=`rgba(120,180,255,${p.a})`;bx.fill()} requestAnimationFrame(loop)})();
  </script>

  <!-- TFJS + COCO-SSD + Pose-Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <script>
    // DOM
    const cam=document.getElementById('cam'), overlay=document.getElementById('overlay');
    const startBtn=document.getElementById('startBtn'), autoBtn=document.getElementById('autoBtn'), snapBtn=document.getElementById('snapBtn');
    const conf=document.getElementById('conf'), confVal=document.getElementById('confVal'), camSelect=document.getElementById('camSelect');
    const statusEl=document.getElementById('status'), desc=document.getElementById('desc'), dbg=document.getElementById('dbg'), hint=document.getElementById('hint');
    const statsBox=document.getElementById('stats'), brand=document.getElementById('brand');

    function log(x){ dbg.textContent += '\n' + x; dbg.scrollTop = dbg.scrollHeight; console.log(x); }

    // State
    let model=null, poseDetector=null, auto=false, rafId=null, currentDeviceId=null;
    let tracks=[]; // {id, class, bbox, score, miss}
    let nextId=1;
    let lastTime=performance.now(), frames=0;
    let lastRun=0, minInterval=40; // ~25 FPS throttle for auto-loop
    let devicesCache=[]; let camIndex=0;
    const PD = window.poseDetection;

    // Memory
    function memLoad(){ try{ return JSON.parse(localStorage.getItem('visionMemory')||'{}'); }catch{ return {}; } }
    function memSave(obj){ localStorage.setItem('visionMemory', JSON.stringify(obj)); }
    function memInc(label){ const m=memLoad(); m[label]=(m[label]||0)+1; memSave(m); }
    function memClear(){ localStorage.removeItem('visionMemory'); }

    // Backend choice
    async function pickBackend(){
      const prefs=['webgpu','webgl','wasm'];
      for(const b of prefs){
        try{ await tf.setBackend(b); await tf.ready(); log('Backend: '+tf.getBackend()); break; }
        catch(e){ log('Backend fail '+b+': '+e.message); }
      }
      try{ tf.env().set('WEBGPU_USE_FP16', true); }catch{}
      statusEl.textContent = `Model: loading… (backend ${tf.getBackend()})`;
    }

    function fitOverlay(){
      overlay.width = cam.videoWidth || 640;
      overlay.height = cam.videoHeight || 480;
      overlay.style.width = cam.clientWidth + 'px';
      overlay.style.height = cam.clientHeight + 'px';
    }

    // Color
    function simpleColorName(r,g,b){
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const s = max===0?0:(max-min)/max;
      if(max<40) return 'black';
      if(min>220) return 'white';
      if(s<0.1) return 'gray';
      if(r>g+20 && r>b+20) return 'red';
      if(g>r+20 && g>b+20) return 'green';
      if(b>r+20 && b>g+20) return 'blue';
      if(r>180 && g>180 && b<120) return 'yellow';
      return 'color';
    }
    function avgColorInBox([x,y,w,h]){
      const tmp=document.createElement('canvas'); tmp.width=Math.max(1,Math.floor(w)); tmp.height=Math.max(1,Math.floor(h));
      const tctx=tmp.getContext('2d',{willReadFrequently:true});
      tctx.drawImage(cam, x, y, w, h, 0, 0, tmp.width, tmp.height);
      const {data} = tctx.getImageData(0,0,tmp.width,tmp.height);
      let r=0,g=0,b=0,n=data.length/4;
      for(let i=0;i<data.length;i+=4){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; }
      r=Math.round(r/n); g=Math.round(g/n); b=Math.round(b/n);
      return {r,g,b,name:simpleColorName(r,g,b)};
    }

    // Tracking (IoU + smoothing)
    function iou(a,b){
      const [ax,ay,aw,ah]=a, [bx,by,bw,bh]=b;
      const x1=Math.max(ax,bx), y1=Math.max(ay,by);
      const x2=Math.min(ax+aw,bx+bw), y2=Math.min(ay+ah,bx+bh);
      const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1);
      const ua=aw*ah + bw*bh - inter;
      return ua>0? inter/ua : 0;
    }
    function updateTracks(dets, threshold){
      const matched=new Set(), newTracks=[];
      for(const t of tracks){
        let best=-1, bestIoU=0, bestIdx=-1;
        for(let i=0;i<dets.length;i++){
          if(matched.has(i)) continue;
          const d=dets[i]; if(d.score<threshold) continue;
          const ov = iou(t.bbox, d.bbox);
          if(ov>bestIoU){ bestIoU=ov; bestIdx=i; best=d; }
        }
        if(bestIoU>0.25){
          matched.add(bestIdx);
          const nb = best.bbox.map((v,i)=> 0.7*t.bbox[i] + 0.3*v );
          newTracks.push({id:t.id, class:best.class, bbox:nb, score:best.score, miss:0});
        }else{
          if(t.miss<2) newTracks.push({...t, miss:t.miss+1});
        }
      }
      for(let i=0;i<dets.length;i++){
        if(matched.has(i)) continue;
        const d=dets[i];
        if(d.score>=threshold){
          newTracks.push({id:nextId++, class:d.class, bbox:d.bbox, score:d.score, miss:0});
        }
      }
      tracks=newTracks;
      return tracks.filter(t=>t.miss===0);
    }

    // Draw / summary / FPS
    function drawBoxes(items){
      const ctx=overlay.getContext('2d');
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.lineWidth=2; ctx.font='14px ui-monospace, Consolas, monospace';
      items.forEach(o=>{
        const [x,y,w,h]=o.bbox;
        ctx.strokeStyle='rgba(120,180,255,0.95)';
        ctx.fillStyle='rgba(10,16,28,0.75)';
        if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(x,y,w,h,8); ctx.stroke(); }
        else { ctx.strokeRect(x,y,w,h); }
        let tag = `${o.class}${o.color?` (${o.color.name})`:''} ${o.score.toFixed(2)} #${o.id}`;
        const tw = ctx.measureText(tag).width+8;
        ctx.fillRect(x, y-20, tw, 20);
        ctx.fillStyle='#cde3ff'; ctx.fillText(tag, x+4, y-6);
      });
    }

    function drawPose(poseInfo){
      if(!poseInfo) return;
      const ctx = overlay.getContext('2d');
      // نقاط رئيسية
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      poseInfo.keypoints.forEach(p=>{
        const sc = (p.score ?? p.confidence ?? 0);
        if(sc > 0.45){
          ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
        }
      });
      // نص الإيماءة
      let msg = [];
      if(poseInfo.leftUp)  msg.push('Left hand up');
      if(poseInfo.rightUp) msg.push('Right hand up');
      if(msg.length){
        ctx.font='16px ui-monospace, Consolas, monospace';
        ctx.fillStyle='#86ffe5';
        ctx.fillText(msg.join(' · '), 12, 22);
      }
    }

    function summarize(items, poseInfo){
      if(items.length===0 && !poseInfo){ desc.textContent='No clear objects.'; return; }
      const counts={}; items.forEach(p=> counts[p.class]=(counts[p.class]||0)+1 );
      const ordered=Object.entries(counts).sort((a,b)=>b[1]-a[1]).map(([k,v])=>`${k}: ${v}`).join(', ');
      let parts=[];
      if(ordered) parts.push('Objects '+ordered);
      if(poseInfo){
        if(poseInfo.leftUp || poseInfo.rightUp){
          parts.push('Gestures ' + [
            poseInfo.leftUp?'Left hand up':null,
            poseInfo.rightUp?'Right hand up':null
          ].filter(Boolean).join(' & '));
        }
      }
      desc.textContent = parts.length? parts.join(' — ')+'.' : 'No clear objects.';
    }

    function tickFps(){
      frames++; const now=performance.now();
      if(now-lastTime>1000){
        statusEl.textContent=`Model: ready ✅ — FPS ${frames}`;
        frames=0; lastTime=now;
      }
    }

    // Detection (with throttle in auto mode)
    async function detectOnce(){
      try{
        fitOverlay();

        // === COCO-SSD objects ===
        const preds = await model.detect(cam);
        const threshold=parseFloat(conf.value);
        const keep = preds.filter(p=>p.score>=threshold).map(p=>({
          class:p.class, bbox:p.bbox, score:p.score
        }));
        const active = updateTracks(keep, threshold);

        // Color + memory
        active.forEach(a=>{
          a.color = avgColorInBox(a.bbox);
          memInc(a.class);
        });

        // === Pose Detection (MoveNet) ===
        let poseInfo = null;
        if (poseDetector){
          const poses = await poseDetector.estimatePoses(cam, { flipHorizontal:false });
          if (poses && poses[0] && poses[0].keypoints){
            const kp = Object.fromEntries(
              poses[0].keypoints.map(k => [k.name || k.part || k.index, k])
            );
            const Ls = kp['leftShoulder'], Rs = kp['rightShoulder'];
            const Lw = kp['leftWrist'],   Rw = kp['rightWrist'];
            function good(p){ return p && (p.score ?? p.confidence ?? 0) > 0.45; }
            let leftUp=false, rightUp=false;
            if (good(Ls) && good(Lw)) { leftUp  = (Lw.y < Ls.y - 10); }
            if (good(Rs) && good(Rw)) { rightUp = (Rw.y < Rs.y - 10); }
            poseInfo = { leftUp, rightUp, keypoints: poses[0].keypoints };
          }
        }

        // Draw + summarize
        drawBoxes(active);
        drawPose(poseInfo);
        summarize(active, poseInfo);
        tickFps();
      }catch(e){ log('detect error: '+e.message); }
    }

    function autoLoop(t){
      if(!auto) return;
      if(!lastRun || (t-lastRun)>=minInterval){
        lastRun=t;
        detectOnce().finally(()=>{ requestAnimationFrame(autoLoop); });
      }else{
        requestAnimationFrame(autoLoop);
      }
    }

    // Camera
    async function listCams(){
      try{
        const devs = await navigator.mediaDevices.enumerateDevices();
        const vids = devs.filter(d=>d.kind==='videoinput');
        devicesCache = vids;
        camSelect.innerHTML = vids.map((v,i)=>`<option value="${v.deviceId}">${v.label||'Camera '+(i+1)}</option>`).join('');
        if(vids[0]){ currentDeviceId = vids[0].deviceId; camIndex=0; }
        log('Cams: '+vids.map(v=>v.label||v.deviceId).join(', '));
      }catch(e){ log('enumerateDevices error: '+e.message); }
    }
    async function startStream(id=null){
      const cs = { video: id?{deviceId:{exact:id}}:{width:{ideal:960},height:{ideal:720},frameRate:{ideal:30,max:60}}, audio:false };
      const s = await navigator.mediaDevices.getUserMedia(cs);
      cam.srcObject = s;
      await new Promise(r=> cam.onloadedmetadata=r);
      await cam.play();
      fitOverlay();
      log('Cam started '+cam.videoWidth+'x'+cam.videoHeight);
      startBtn.textContent='Camera: ON';
      hint.style.display='none';
    }
    async function startCam(){
      try{
        if(location.protocol!=='https:' && location.hostname!=='localhost'){
          hint.textContent='⚠️ Use HTTPS (GitHub Pages) to access the camera.'; hint.style.display='block';
        }
        await listCams(); await startStream(currentDeviceId);
      }catch(e){
        log('startCam error: '+e.name+' '+e.message);
        statusEl.textContent='Camera blocked';
        if(e.name==='NotAllowedError'){
          hint.textContent='⚠️ Please allow camera access from the address bar.'; hint.style.display='block';
        }else if(e.name==='NotFoundError'){
          hint.textContent='⚠️ No camera found. Plug one or choose another from the selector.'; hint.style.display='block';
        }
      }
    }

    // Stats overlay (hidden UI)
    function renderStats(){
      const m = memLoad();
      const entries = Object.entries(m).sort((a,b)=>b[1]-a[1]);
      statsBox.textContent = entries.length? 'Stats (localStorage):\n'+entries.map(([k,v])=>`- ${k}: ${v}`).join('\n') : 'No memory yet.';
    }
    function toggleStats(){
      renderStats();
      statsBox.style.display = (statsBox.style.display==='none'||!statsBox.style.display)?'block':'none';
    }

    // UI wiring
    startBtn.onclick = startCam;
    camSelect.onchange = async e=>{ currentDeviceId=e.target.value; if(cam.srcObject){ cam.srcObject.getTracks().forEach(t=>t.stop()); } await startStream(currentDeviceId); };
    snapBtn.onclick = detectOnce;
    autoBtn.onclick = ()=>{ auto=!auto; autoBtn.textContent='Auto: '+(auto?'ON':'OFF'); if(auto) requestAnimationFrame(autoLoop); };
    conf.oninput = ()=> confVal.textContent = conf.value;

    // Keyboard shortcuts
    window.addEventListener('keydown', async (ev)=>{
      if(ev.target && (ev.target.tagName==='INPUT' || ev.target.tagName==='TEXTAREA')) return;
      if(ev.key==='a' || ev.key==='A'){ autoBtn.click(); }
      else if(ev.key===' '){ ev.preventDefault(); snapBtn.click(); }
      else if(ev.key==='+'){ conf.value = Math.min(0.95, (+conf.value + 0.05)).toFixed(2); conf.dispatchEvent(new Event('input')); }
      else if(ev.key==='-'){ conf.value = Math.max(0.2, (+conf.value - 0.05)).toFixed(2); conf.dispatchEvent(new Event('input')); }
      else if(ev.key==='c' || ev.key==='C'){
        if(devicesCache.length>1){
          camIndex = (camIndex+1)%devicesCache.length;
          camSelect.selectedIndex = camIndex;
          const id = devicesCache[camIndex].deviceId;
          if(cam.srcObject){ cam.srcObject.getTracks().forEach(t=>t.stop()); }
          await startStream(id);
        }
      }
      else if(ev.key==='s' || ev.key==='S'){
        if(ev.shiftKey){ memClear(); renderStats(); statsBox.style.display='block'; statsBox.textContent='Memory cleared.'; }
        else toggleStats();
      }
    });

    // Double-click the brand to toggle stats as well
    brand.ondblclick = toggleStats;

    // Init
    (async function init(){
      await pickBackend();
      try{
        model = await cocoSsd.load({base:'mobilenet_v2'});
        statusEl.textContent='Model: ready ✅';
        log('COCO-SSD ready');
      }catch(e){
        statusEl.textContent='Model failed'; log('Model load error: '+e.message);
      }

      try{
        const mdl = PD.SupportedModels.MoveNet;
        poseDetector = await PD.createDetector(mdl, {
          modelType: PD.movenet.modelType.SINGLEPOSE_LIGHTNING
        });
        log('Pose model ready');
      }catch(e){
        log('Pose model load error: '+e.message);
      }

      setTimeout(()=>startCam().catch(()=>{}), 300);
    })();
  </script>
</body>
</html>